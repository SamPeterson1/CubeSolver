# About

Stickers is a 3D twisty puzzle solver that can handle a variety of common puzzles such as the Rubik's Cube, Pyraminx, Square 1, Ivy Cube, and Skewb. The solves generated by this application are NOT reverse scrambles and will work with ANY scramble.
However, the solving algorithm for the Skewb is not yet implemented. Additionally, for both the Rubik's Cube and Pyraminx, the user can set the size of the puzzle to any number. 
The rendering of each puzzle is implemented from scratch in OpenGL.

# Building and Running

This project uses the gradle build system. To run, simply run 
```console 
./gradlew run
```

To export the project into a jar file, instead run
```console
./gradlew shadowjar
```
The generated jar file will be in app/build/libs/app-all.jar

# Usage

Here is a brief explanation of each GUI component and its function

### Puzzle Viewport

This renders the 3D puzzle, and the camera can be moved by left clicking and dragging, as well as zoomed in and out using the scroll wheel.

### Puzzle Selector

This dropdown box is located at the top left corner of the screen, and clicking on the green arrow will reveal a list of puzzles to be chosen from.
Simply click on the puzzle's name to change to it.

### Size Selector

This text box is located to the right of the puzzle selector. To change the size of the current puzzle, click on the text box, type in a number, and press enter. The entered size may be capped/ignored if it is invalid.

### Animation Speed Slider

This slider is located at the top right corner of the screen. By default, the animation speed is maxed out to a number that is unattainable by using the slider. Once the slider is moved, this speed is not reachabule unless you restart the program.
Moving the slider all the way to the left will pause the animation and stop any moves from being executed.

### Executing Algorithms

There is a text box labled "Algorithm" that provides a way for the user to enter an algorithm to then be executed. A well-formed algorithm is generally a list of moves separated by spaces.

Generally, a move is the name of an axis (i.e 'F', 'R', 'U', ...etc) followed by an optional number to indicate the number of times the axis should be rotated.
A complete list of each axis and its name can be found in com.github.sampeterson1.puzzle.moves.Axis. After that, a move may contain an inclusive range of layers such as [0,2] or [1]. 
Layer indices may be negative and are converted to positive indices by adding the size of the puzzle. And finally,
an apostrophe (') at the end of a move indicates that the move should be inverted (counterclockwise turn instead of clockwise). 
For example, the move "F3[1,-1]'" executed on a size 10 Rubik's Cube would rotate the axis corresponding to the front face of the cube counterclockwise in layers 1-9 (inclusive).

Certain puzzle types also have specific algorithm syntax that override what was mentioned above.

The Square-1 follows the standard move notation described in almost all speedsolving guides with NO SPACES.
For instance, "(1,-1)/(-1,1)/", "//", and "(1,0)/(-1,-1)/(-2,4)/(-1,-1)/(1,0)" are all valid algorithms. If the puzzle is in a state such that the "/" move is not possible, it will be ignored.
Also, be very careful that the algorithm is in the correct format because there is no error handling implemented yet in parsing these types of algorithms.

Additionally, the Rubik's Cube implements the cube rotations "x", "y", and "z", and the Pyraminx implements the rotations "r", "l", "f", "u".
By themselves, these rotations produce no effect. However, when placed in the context of an entire algorithm, they will transpose the algorithm such that moves executed after the rotation
are executed from the perspective of the rotated puzzle. This is useful when running many common speedsolving algorithms that use cube rotations, such as the PLL algorithm "z U R' D R2 U' R D' U R' D R2 U' R D' z' U'".

After an algorithm is entered, press the "Execute" button to run the algorithm.

### Scrambling

Entering a scramble length into the text box and pressing the "Scramble" button will run a series of randomized moves on the puzzle.

### Solving

Solving the puzzle is as simple as pressing the "Solve" button. Depending on the size/type of the puzzle, this could take a while. Be patient! However, for most "reasonable" puzzle sizes, this process should be nearly instant.
For longer solves, check the standard output, as certain solvers print their progress along the way. To reiterate the introduction, the solves generated by this application are NOT reverse scrambles and will work with ANY scramble.
